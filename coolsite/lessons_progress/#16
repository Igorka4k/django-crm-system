ОСНОВЫ ORM (более подробно)

<Вторичная модель>_set - аттрибут, через который можно из первичной модели управлять вторичной
связанной моделью. (category.women_set.all() - все экземпляры класса Women)

ФИЛЬТРЫ

Women.objects.filter(<атрибут>__contains='<str>') - Фильтровать записи по наличию указанной
 строки в атрибуте. (объекты не упорядочены)
 другие фильтры можно найти в документации.

Можно также отфильтровывать данные первичной модели из вторичной:
Women.objects.filter(cat__name__contains="цы")  # комбинируемо с фильтрами.

Работа с классом Q (from django.db.models import Q)
>>> Women.objects.filter(Q(pk__lt=5) | Q(cat_id=2))

Сортировка полей DateTime:
>>> Women.objects.latest('time_update'/'time_create')  # earliest, latest

Получение предыдущей и следующей записей на основе текущей:
w.get_previous_by_<имя поля для отбора>(**<доп условие для отбора>)  # предыдущая

w.get_next_by<имя поля для отбора>(**<доп условие для отбора>)  # следующая

exist() - проверка существования рубрики
count() - проверка кол-ва записей

Функции агригации (повторить):

.aggregate(Min('cat_id'), Max('cat_id')) - при применении вернёт словарь, елементами которого будут являться результаты указанных
 функций в параметрах...

.aggregate(<ключ елемента, который появиться в словаре>=Min('cat_id')) - так можно задать ключ елемента словаря.
.aggregate(res=Avg('cat_id')) - среднее арифметическое id данных записей.


>>> Women.objects.values('title', 'cat_id').get(pk=1)


Хуйита непонятная с агрегациями:
после 42.00 у меня отрубился мозг и я нихуя не понял работу метода .annotate и всё что с ним связано.

=========
Подробнее о работе метода values()

- Возвращает список словарей, элементами которых являются поля со значениями из бд,
 информирующие определённое поле, которое описывает сам словарь.
>>> Women.objects.values('id', 'title', 'cat_id') ==>
    <Query set [{'id': 1, 'title': 'Ариана Гранде', 'cat_id': 2}, ...]>

=========
_разборки с методом annotate_
Women.objects.values('cat_id').annotate(Count('id')) - говорит нам о кол-ве записей для каждой
 категории. Работа воспроизводится со вторичной моделью (Women)

 Короче всё проясняется:

 annotate - такой же посредник для использования агригирующих функций как и aggregate.

 annotate(Count('title')) - выводит кол-во названий (title в данном случае)
 для каждого значения поля, которое указано в values. проще говоря, если у поля есть заголовок, то
 элемент словаря (который каким-то образом генерируется при использовании Count) увеличивается на 1.

 если работа происходит не с values а с обычным списком объектов, то у каждого объекта появляется аттрибут,
 который генерирует агригатирующая функция, что эквивалентно элементу, который генерировался у нас в словаре.
 # Например у каждого объекта списка всех категорий аттрибут women__count, который показывает
  кол-во записей, относящихся к данной категории, появится после выполнения следующей команды:
  Categories.objects.annotate(Count('women'))
  c = _  # присвоить значение полученных из последней отработанной строчки/операции данных,
  которые ещё не были присвоены никакой другой переменной (проще говоря, если их результат был
   выведен в консоль для ознакомления).
  с.[0].women__count

 ТАКЖЕ: Можно задать название аттрибутам, которые будут сгенерированны с помощью агригирующих функций,
 задав в annotate() вместо позиционного аргумента именной: .annotate(<my_title>=Count('women'))
=========


КЛАСС F

Для операций между полями одной и той же записи или для их изменения:

 - Women.objects.filter(pk__gt=F('cat_id'))

 - (1 вариант):
  Women.objects.filter(slug='maks-kravchenka').update(views=F('views')+1)  # Предположим что экземпляр модели Women имеет поле views.

 - (2 вариант):
  w = Women.objects.get(pk=1)
  w.views = F('views') + 1  # Несмотря на то, что мы явно не передаём экземпляр класса Women в класс F он будет работать корректно, хз как.
  w.save()

  ПРИМЕЧАНИЕ: Изменение атрибутов экземпляра класса именно через класс F решает задачу ассинхронности,
  поэтому использовать w.views += 1, запрещается в целях сохранения многопользовательности.

